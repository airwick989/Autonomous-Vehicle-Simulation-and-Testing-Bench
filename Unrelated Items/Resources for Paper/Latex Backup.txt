\documentclass[conference]{IEEEtran}
\usepackage{blindtext, graphicx}

% *** CITATION PACKAGE ***
\usepackage{cite}

% *** GRAPHICS RELATED PACKAGES ***
\ifCLASSINFOpdf
\else
\fi

% *** SPECIALIZED LIST PACKAGES ***
\usepackage{amsmath}

% *** SUBFIGURE PACKAGES ***
\usepackage[tight,footnotesize]{subfigure}

% *** TABLE PACKAGES ***
\usepackage{multirow}
\usepackage{longtable}

% *** PDF, URL AND HYPERLINK PACKAGES ***
\usepackage{array}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage[export]{adjustbox}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{pifont}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{tcolorbox}
\usepackage{multicol}
\usepackage{amsthm}
\usepackage{commath}
\usepackage{multirow}
\usepackage{oz, amsfonts}
\newtheorem{definition}{Definition}[]
\newtheorem{case-study}{Case-Study}[]
\newtheorem{exmp}{Example}[]
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\renewcommand{\thesection}{\arabic{section}}
\def\thesectiondis{\thesection.} \def\thesubsectiondis{\thesectiondis\arabic{subsection}.} \def\thesubsubsectiondis{\thesubsectiondis\arabic{subsubsection}.} \def\theparagraphdis{\thesubsubsectiondis\arabic{paragraph}.}

\title{The Design and Development of a Widely Accessible Autonomous Vehicle Simulation System}
\author{\IEEEauthorblockN{Ridwan Hossain}
\IEEEauthorblockA{Department of Electrical, Computer and \\ Software Engineering\\
Ontario Tech University, Canada\\
Email: ridwan.hossain@ontariotechu.net}
}
\date{June 2022}
\begin{document}
\maketitle


\begin{abstract}
There currently exists a need for a platform that provides users with the ability to perform extensive, repeatable and meaningful simulation and testing for an autonomous vehicle system whilst being broadly accessible, widely supported and provides robust features and development tools. The contemporary implementations of similar systems are either financially exorbitant or highly regulated and contained. The system reflected in this paper aims to fill a gap in the industry of autonomous vehicles and infrastructure by providing a highly robust and streamlined platform to support the development of autonomous vehicle driving systems using widely supported and easily accessible open-source software. This paper will outline the design and development of a proposed system to fulfill this need. Everything from the software tools and hardware components chosen will be discussed, as well as the features constructed throughout the development process. The results and benefits proceeding from the development of the system will also be presented, and future plans for the system will be highlighted.  
\end{abstract}


\section{Introduction}
With the rapid growth experienced by the autonomous vehicle industry, the need for development support is a point of focus which is becoming much more paramount. "The global autonomous vehicle market was estimated USD 94.43 billion in 2021 and is is projected to hit around USD 1808.44 billion by 2030" [1]. While there is clear evidence of the dominating presence of autonomous vehicle technology, the availability of tools and platforms to provide backing for the development of autonomous vehicle systems is much less strong. Currently, the most used software platforms to support the development of autonomous vehicle driving systems, such as RTI, Adasis and Waymo for example, are highly contained and available only to large industrial vehicle manufacturers who posses the resources and funds to partner with such companies [2]-[5]. There exists no readily available simulation and development platform in this industry and large vehicle manufacturers all have personal access to such facilities, making access to such tools highly contained. Exorbitant costs of development tools also pose as a barricade as "current estimates for the cost of a self-driving hardware and software package range from \$70,000 to \$150,000" (USD) [6]. 

In addition to the lack availability, there exists a need in the autonomous vehicle development space for a widely supported platform which provides the ability to perform repeatable, testable and highly extendable development and simulation activities. As of 2020, at least \$16 Billion USD has been expended towards autonomous vehicle system testing across only 30 companies [7]. One of the largest companies involved, Waymo, spent \$3.5 Billion USD alone performing testing activities [8]. The frequency of testing which may be performed is also constrained by currently adopted methods. One could run tests on an autonomous vehicle system using a live vehicle, but that would allow thorough testing to feasibly occur every few days. 

From the evidence presented, it is apparent that there is a need in the autonomous vehicle development space for a platform the fulfills the mentioned needs and criteria. The contemporary implementations of similar systems are either financially exorbitant or highly regulated and contained. In order to fill this gap in the industry, research and development was conducted to develop a system which will target the critical areas of interest as highlighted previously. The goal of the proposed system is to provide a hardware bench that can streamline the development process by providing robust testing and development tools, a highly extendable and modifiable platform, an intuitive and interactive environment, all whilst containing repeatable consistent data logging features. In addition, one of the primary goals of the proposed system is to be easily accessible and widely supported, as such, the choices of both the software and hardware are critical. 

This paper will outline the design and construction of a platform that was established to support the development and simulation of autonomous vehicle driving systems and algorithms. Everything from the software tools and hardware components chosen will be discussed, as well as the features constructed throughout the development process. The results and benefits proceeding from the development of the system will also be presented, and future plans for the system will be highlighted.


\section{Preliminary System Objectives}
This section will outline more specifically what features the system aims to have and what objectives it projects to meet. Shown below is a list containing the specific action items to be achieved as a result of the development of the system.

\begin{enumerate}
\item A software platform that: 
    \begin{itemize}
        \item Contains a wide selection of tools and resources to perform advanced simulation activities of autonomous vehicle systems and their environments.
        \item Has real-time traffic control and traffic flow simulation.
        \item Provides interfaces to access key data and parameters from the simulations.
        \item Contains built-in sensors which simulate the behaviour of their real-world counterparts.
        \item Supports multiple maps and locations.
        \item Contains varying time-of-day and weather controls.
    \end{itemize}
\item Hardware peripherals which provide a more cohesive experience to the user by providing the following:
    \begin{itemize}
        \item Steering Wheel
        \item Pedals
        \item Gear Shifter
        \item Gauge Cluster
    \end{itemize}
\item A head unit containing a widely used operating system to communicate useful data to and from the simulator and also support application development.
\item Integrate a CAN (Control Area Network) bus into the system.
\item Data recording functionalities which automatically outputs and visualizes large data sets.
\item Design an automated testing framework to support continuous integration and development for the system.
\end{enumerate}

The end result of obtaining these objectives is an autonomous vehicle system simulation and development platform in the form of a hardware bench. This bench should provide the ability to easily record simulation telemetry of both manual driving and autonomous driving while providing meaningful data to support the development of autonomous driving algorithms. This bench should also allow for testing activities to take place regarding various aspects of an autonomous vehicle system in order to streamline the development process. The entire system should also be designed in such a manner that the software components are easily modifiable to meet development needs.


\section{Tools, Technologies and Materials Chosen}
This will highlight what choices have been made in regards to the selection of tools and technologies for the key areas of the simulation bench.

\subsection{Selection of the Base Software Platform}
The software platform that was chosen to be the base of the simulation bench was CARLA. CARLA (Car Learning to Act) has been "developed from the ground up to support development, training, and validation of autonomous driving systems. In addition to open-source code and protocols, CARLA provides open digital assets (urban layouts, buildings, vehicles) that were created for this purpose and can be used freely. The simulation platform supports flexible specification of sensor suites, environmental conditions, full control of all static and dynamic actors, maps generation and much more" [9].

As CARLA is an open-source software platform, it is much more accessible than other, more proprietary methods. Being open-source allows anyone to be able to access the software and begin development with very little setup. This aspect also promotes continuous support as a larger user base has access to the platform and may suggest improvements or help to implement those improvements as well. 

Furthermore, CARLA supports key features which was targeted for the simulation bench in the preliminary objectives. Some of the features present in CARLA include:
    \begin{itemize}
        \item A powerful API that provides the ability to access data from and control various aspects of the simulator, such as "traffic generation, pedestrian behaviors, weathers, sensors, and much more" [9].
        \item Supports a flexible specification of numerous sensor suites, such as "LIDARs, multiple cameras, depth sensors and GPS among others" [9].
        \item Offers advanced simulation of traffic flow and road behaviors [9].
        \item Allows users to import or generate custom maps using third part software to be used in the simulation environment [9].
        \item Has the ability to simulate various weather and time-of-day conditions which have real-time effects on the dynamics of vehicles and traffic [9].
    \end{itemize}
    
CARLA has been written in Python and has been designed to be highly modifiable and extendable [9]. This is to easily allow the addition of new features and to support the development of autonomous vehicle driving algorithms in the CARLA platform. CARLA has shown to be a very promising base for the simulation bench. 

\subsection{Hardware Peripherals to be Connected to the Software}
The CARLA software mentioned previously comes preconfigured with keyboard controls when driving vehicles in manual mode, meaning autonomous control is inactive [9]. These keyboard controls are perfectly suitable for testing purposes focusing on autonomous driving and is not necessary if that is the primary focus, however, the simulation bench should be able to simulate both manual and autonomous driving nearly simultaneously by allowing users to switch between the modes in real-time. This would allow for better testing and development opportunities. 

In order to provide that cohesive experience to better simulate real-world driving, various hardware peripherals were paired with the software to provide a more familiar method for users to interface with the simulation bench. 

Found below is a Bill of Materials for the hardware components used for manual control [10]-[11]:
\begin{table}[!ht]
    \centering
        \begin{tabular}{ |c|c|c| } 
            \hline
            \multicolumn{3}{|c|}{Control Peripherals BOM} \\
            \hline
            Item & Quantity & Price (CAD) \\
            \hline
            USB steering wheel/pedals & 1 & 160 \\ 
            Cluster (BMW e36) & 1 & 200 \\ 
            Arduino Uno & 1 & 30 \\ 
            DC jack socket plug & 1 & 5 \\ 
            AC power supply & 1 & 10 \\ 
            \hline
        \end{tabular}
    \caption{[10]-[11]}
\end{table}

For the head unit that will communicate with the simulator, an Android-based infotainment was chosen. This is because the Android operating system is widely supported in the application of external device and software connectivity while also having the most users [12]. The Android operating system holds over 43\% of the OS market share worlwide, with "over 2.5 billion active users spanning over 190 countries" [13], [12]. Due to this large support, there exists tools and packages that provide communication interfaces with the operating system, making an Android-based head unit a perfect candidate. 

Found below is a Bill of Materials for the hardware components used for implementing the head unit to the simulation bench [11]:
\begin{table}[!ht]
    \centering
        \begin{tabular}{ |c|c|c| } 
            \hline
            \multicolumn{3}{|c|}{Head Unit Connection BOM} \\
            \hline
            Item & Quantity & Price (CAD) \\
            \hline
            Android Head Unit & 1 & 450 \\ 
            Power Supply & 1 & 110 \\ 
            USB-USB Connector & 1 & 10 \\ 
            \hline
        \end{tabular}
    \caption{[11]}
\end{table}

\subsection{Facilitating Communication with the Android Head Unit}
Communication between the Android-based head unit and the simulation software will be enabled using the Android-developed Android Debug Bridge (ADB). 

The ADB is a powerful command-line tool which facilitates communication and data transfer to and from an Android device [14]. It essentially acts as in interface for transmitting and receiving messages/data to and from a device running the Android operating system [14]. The ADB allows for the control of various device functions, installing and debugging applications, running commands on the device externally, retrieving data from the device, etc [14].  

The simulation software will use the pure-python-adb Python package in order to create a communication bridge between the Python-based simulator and the ADB interface [15]. This library will allow the simulation software to use the ADB interface's functionalities using purely Python code [15]. 

\subsection{CAN Technologies to be Integrated into the System}
To support CAN development and testing on the simulation bench, the cantools (CAN Bus Tools) Python package and the CANdevStudio software for Linux will be used. 

The cantools package provides tools that provide the ability to perform CAN data encoding and decoding, CAN bus generation and monitoring, network node testing and many others [16]. This package provides powerful functions which will allow the simulation bench to establish CAN buses, enabling vehicle subsystem communication and interpretation of CAN data to and from vehicle networks [16]. 

The CANdevStudio software is a CAN simulation software which aims to provide cost-effective means of simulating CAN messages and providing an easy-to-use interface for sending CAN signals [17]. CANdevStudio has been specifically designed keeping automotive development in mind and functions with various forms of hardware interfaces as well as virtual [17]. 

\subsection{Tools Chosen to Construct the Testing Framework}
The continuous testing and development framework is planned to primarily be developed using the Python Unittest library and the Jenkins platform. 

The Python Unittest library provides a unit testing framework for Python 3 environments [18]. It provides a wide array of functions to support "test automation, sharing of setup and shutdown code for tests, aggregation of tests into collections, and independence of the tests from the reporting framework" [18]. Python Unittest will allow for effortless construction of complex and thorough test suites that will be run on the simulation bench while also running setup and tear down of the test cases automatically [18].

The Jenkins platform is the leading open-source automation server and "provides hundreds of plugins to support building, deploying and automating any project" [19]. This allows for Jenkins to be fashioned as a continuous integration an testing server, allowing for the automation of unit testing, integration testing, and regression testing as changes in the code are committed [19]. Jenkins can be used to automate the testing framework on the simulation bench, such that as updates are pushed to the simulation bench's repository, a slew of testing activities automatically take place to ensure the integrity of both the system and the changes being made to it [19].


\section{High-Level System Architecture Overview}
This section will outline the the general architecture and control flow of the major hardware and software aspects of the simulation bench. The hardware architecture making up the simulation bench can be found below [10]:
\begin{figure}[h]
  \centering
      \includegraphics[width=0.50\textwidth]{Hardware Layout.drawio.png}
  \caption{System Hardware Communication [10]}
\end{figure}

\subsection{Server Multi-client Architecture}
An important point contention is that the CARLA architecture is structured in a client-server fashion [9]. The world in which the simulation takes place in will contain the map, all environmental assets, and will be responsible for rendering those elements [9]. In addition, all traffic rendering and simulation will also take place on the server-side [9]. This allows for high scalability as a server machine may serve multiple client machines, creating a server multi-client architecture [9]. Adopting this architecture allows multiple clients in the same or different nodes to control different actors (vehicles) in the same world [9]. Alternatively, the client and server may also exist on the same machine [9].

\subsection{Control Peripherals}
A user of the simulation bench will interact with only the client machine, where simulation of the testing vehicle takes place. The user will primarily interface through the steering wheel/pedals/shifter kit, but may also use the keyboard for additional functions such as switching which sensors are monitored, changing environment variables, performing ADB functions, etc. All these inputs will be sent to and interpreted by the simulation software on the client machine.

Using CARLA's extensive API, the original input mapping was rebound to correctly comprehend the input received from the newly connected hardware peripherals. As some input from the hardware peripherals are analog, notably the pedals, some processing was done using logarithmic functions to correctly translate the input data when being sent to the simulation software. 

\subsection{Arduino Microcontroller and Gauge Cluster}
As the gauge cluster strictly uses analog signals which are read using serial pins, there exists no easily accessible interface to communicate digital data from the simulation software to the cluster. As a result, an Arduino microcontroller is required to act as a middleware of communication between the simulation software and the gauge cluster hardware. Shown below is a realistic schematic of the physical connections required to enable signal communication between the microcontroller and the gauge cluster [20]:
\begin{figure}[h]
  \centering
      \includegraphics[width=0.43\textwidth]{arduino_to_cluster.jpg}
  \caption{Microcontroller to Cluster Connection Schematic [20]}
\end{figure}

The microcontroller is used to read the digital data exported from the simulation and correctly map it to an analog signal. This remapping procedure was refined extensively to scale to correct physical readings on the gauge cluster. This data processing and conversion is done within an Arduino script that is uploaded into the microcontroller itself.

The data sent from the simulation software consisted of the vehicle speed (Kilometers per Hour) and the crankshaft's angular velocity within the vehicle's engine (Revolutions per Minute).

\subsection{The ADB and Head Unit}
The Android-based head unit is connected to the client machine via USB. With the ADB interface built into the head unit's operating system, the pure-python-adb package on the client machine will be used to establish a communication channel and send commands and data through it. For this communication to be possible, USB debugging needs to be enabled on the Android-based head unit. Found below is a figure outlining the high-level architecture of the client-to-ADB connection [15]:
\begin{figure}[h]
  \centering
      \includegraphics[width=0.5\textwidth]{adb connection.png}
  \caption{ADB Connection Architecture [15]}
\end{figure}

The pure-python-adb package can be used to connect to the Android device by establishing a locally hosted server communicating at TCP port 5037 by default [15]. Using that port as the channel of communication, the ADB server will begin running the ADB daemon on the Android device such that all ADB operations will be handled as a background process [15].\\ 

This concludes the overview of the simulation bench's layout and architecture. The remaining elements that have been implemented into the system are strictly software based and will be covered in following sections.

\section{Enhancements and Features Integrated into the System}
This section will highlight the features and improvements introduced to the simulation bench as incremental developments. The connection and mapping of manual vehicle controls to the hardware peripherals will be omitted from this section as this topic was already previously covered. 

\subsection{ADB Functions and Development Potential}
Upon installing the necessary ADB tools on the simulation bench and establishing the required communications, several features were implemented to the system to take advantage of the Android-based head unit. 

Firstly, a curated library was developed, containing preconfigured methods for controlling various functions on the head unit. This library will allow for future development to more readily take place as many functionalities regarding the control of the head unit has already been developed and may be reused as required. Functionalities include controlling the operating system navigation on the head unit, various user interface controls, and most importantly, application launching and debugging functions. 

Numerous library functions were integrated into the simulation software and mapped to button controls on the steering wheel. Found below is an overview of the button mappings and their corresponding functionalities:
\begin{table}[!ht]
    \centering
        \begin{tabular}{ |c|c| } 
            \hline
            ADB Functionality & Wheel Button Mapping \\
            \hline
            Return to Home Menu & Home Button (bottom-most button) \\ 
            Volume Up & Upper-right Thumb Control \\ 
            Volume Down & Lower-right Thumb Control \\ 
            Play/Pause & Right Circular Button on Right Cluster \\ 
            Play Next Track & Upper Left Thumb Control \\ 
            Play Previous Track & Lower Left Thumb Control \\ 
            Back & Upper-left Diagonal Button from Home \\ 
            Recent Applications & Upper-right Diagonal Button from Home \\ 
            Launch Google Maps & Left Paddle \\ 
            \hline
        \end{tabular}
    \caption{Sample ADB Functions}
\end{table}

The functions above represent the most rudimentary operations which can be undertaken as a result of the ADB implementation. The primary advantage are the testing and debugging capabilities that come with this communication interface. 

Take for example, a user of this simulation bench has developed a driving agent which has advanced far enough that they would like to begin testing the agent's navigational capabilities. As mentioned before, the CARLA platform supports importing custom maps from external software [9]. A replication of real-world driving environments may be imported into the simulation bench and be used for the testing and development of autonomous driving systems. 

The user can take advantage of the simulation bench's capabilities and perform navigation testing on their driving agent within real-world road conditions. The user may develop some functionality into their autonomous driving algorithms to fetch data from the Google Maps application in the Android head unit in order to guide their agent to a waypoint. There exists an API to retrieve Google Maps data which comes included in the Android Software Development Kit [21]. While the user's agent will be responsible for controlling the vehicle and all that it entails, the navigation data guiding the agent can be retrieved from the ADB interface on the head unit. This can save extensive amounts of both money and time by performing a large amount of real-world testing from within a simulation environment and without being constrained by the limitations which come with real-world testing of such systems.

The communication is also possible in the reverse order, where the head unit may retrieve information from the simulation software. Take for example, a user wishes to perform development on user interface features for their driving system, one of which is for lane-invasion warning to appear on the head unit. As the simulation software has built in lane-invasion sensors whose messages can easily be accessed using the CARLA API, this sort of development is possible with the ADB [9].

\subsection{Integration of a CAN Bus}
Modern day vehicles contain multitudes of computers and subsystems which all must communicate successfully. As of 2016, the " average car has 30 to 50 different computers, and high-end cars have as many as 100" [22]. Furthermore, modern day vehicles on average are "accompanied by 60 to 100 different electronic sensors", all of which must function in unison whilst transferring data in real time [22]. This is even more prevalent currently, particularly in the autonomous vehicle space, where an even larger number of sensors and computers which are communicating are present. 

Communication amongst these vehicle subsystems are critical, as a majority of them function in a complementary manner [23]. The traditional means of enabling this communications is through hard-wired means such as circuitry and digital systems [23]. However, the disadvantages of this approach are that it presents challenges when designing the architecture of the vehicle's subsystems and this approach also presents higher costs for both the design and implementation [23]. 
The CAN (Control Area Network) standard was introduced to resolve the drawbacks of the traditional approach by allowing the communication features implemented using software alone [23]. The introduction of the CAN bus saves both time and money on creating complex, hard-wired systems to handle communication between vehicle subsystems [23]. In addition, a CAN bus allows various microcontrollers and devices to communicate with each other's applications directly without the need of a host machine [23]. 

Using the cantools package, a CAN bus was integrated into the simulation bench to enable data transfer among vehicle subsystems. Found below is a figure depicting the high-level architecture of the CAN bus implementation within the client machine:
\begin{figure}[h]
  \centering
      \includegraphics[width=0.47\textwidth]{CAN Architecture.drawio.png}
  \caption{CAN Bus Implementation}
\end{figure}

The cantools package, along with establishing a CAN bus and facilitating the transfer of CAN data, also provides an interface for users to view the data being transmitted on the bus in multiple formats [16]. This CAN data can be decoded using DBC files in order to make reading them more user-friendly [16]. Data being transmitted on the CAN bus can be dumped onto the cantools CAN bus interface and the interface may be used to send data on the bus as well [16]. 

The CAN nodes within the CARLA platform represent devices or sensors within the CARLA simulation software that are transmitting and receiving data on the CAN bus. Those devices have no connection to a CAN by default, this feature was integrated into the software. Found below is a sample screenshot of the CAN bus interface when it is receiving data:
\begin{figure}[h]
  \centering
      \includegraphics[width=0.3\textwidth]{CAN interface.png}
  \caption{cantools CAN Bus Sample Interface}
\end{figure}

Above is a sample decoded capture of the data being transmitted by the simulation software when the vehicle is in motion. The data being shown in the sample consist of individual wheel speeds, the current gear the vehicle's transmission is in, and the steering angle. As shown in the capture, the raw data is shown as hex values and then decoded using a preconfigured DBC file. Much more data can be transmitted across the CAN bus, however these 3 data items were chosen for demonstration purposes. 

The primary reason for the implementation of the CAN bus within the simulation bench was to support future development on autonomous vehicle communication with smart infrastructure. This is when an autonomous vehicle system works in tandem with a smart systems embedded in an environment's infrastructure to improve the autonomous vehicle's driving capabilities and also to improve traffic flow and traffic safety [24]. This is done by having the vehicle's sensors and devices communicate with the smart infrastructure [24]. This uncovers a plethora of possibilities such as having autonomous vehicles know ahead of time what traffic signals will be, adjusting autonomous driving characteristics based off data received from the smart infrastructure, and much more [24]. 

The notion of smart infrastructure communicating with autonomous vehicles is emerging as key solution for safer roads [24]. The CARLA platform has built-in traffic managers which can be used to retrieve traffic and infrastructure data (such as traffic light information) from the CARLA API [9]. These capabilities in conjunction with the integration of a CAN within the simulation bench allows for the future development and simulation of these systems possible on this bench [24].    

Another aspect of CANs which can be simulated in this system are CAN attacks. One of the contingency point regarding the use of CANs are its security [25]. "Integrity is the accuracy, completeness, and validity of the data. The CAN bus has a CRC for verification of integrity against the transmission errors, but it cannot prevent data injected by malicious parties, which breaks the integrity. The protocol does not have a comprehensive integrity check and fails to sustain integrity" ALL THIS BEFORE IS FROM SOURCE 25.

\subsection{Real-time Data Recording and Logging Pipeline}


\end{document}